# 基于搜索的路径规划

## DFS

### 递归版本

```C++
#include <iostream>
#include <vector>
#include <utility> // for pair

using namespace std;

// 定义方向：上、右、下、左（顺时针方向）
const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

// DFS递归函数
bool dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, 
         int x, int y, int ex, int ey, vector<pair<int, int>>& path) {
    // 检查是否超出边界、是否是障碍物、或是否已访问
    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || 
        grid[x][y] == 1 || visited[x][y]) {
        return false;
    }
    
    // 标记当前节点为已访问，并加入路径
    visited[x][y] = true;
    path.push_back({x, y});
    
    // 如果到达终点，返回成功
    if (x == ex && y == ey) {
        return true;
    }
    
    // 向四个方向递归搜索
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (dfs(grid, visited, nx, ny, ex, ey, path)) {
            return true; // 找到路径，立即返回
        }
    }
    
    // 如果所有方向都找不到路径，回溯：从路径中移除当前节点并返回false
    path.pop_back();
    return false;
}

int main() {
    // 示例网格：0可走，1障碍物
    vector<vector<int>> grid = {
        {0, 1, 0, 0, 0},
        {0, 1, 0, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 0, 0, 0},
        {0, 0, 0, 1, 0}
    };
    
    int sx = 0, sy = 0; // 起点坐标
    int ex = 4, ey = 4; // 终点坐标
    
    // 初始化访问标记矩阵
    vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));
    vector<pair<int, int>> path; // 存储找到的路径
    
    // 调用DFS搜索
    bool found = dfs(grid, visited, sx, sy, ex, ey, path);
    
    if (found) {
        cout << "找到路径：";
        for (auto& p : path) {
            cout << "(" << p.first << "," << p.second << ") ";
        }
        cout << endl;
    } else {
        cout << "未找到路径！" << endl;
    }
    
    return 0;
}
```

### 非递归（迭代）版本（使用显式栈）

对于深度较大的图，为了避免递归栈溢出，可以使用显式栈来实现DFS：

```C++
#include <iostream>
#include <vector>
#include <stack>
#include <utility>

using namespace std;

const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

bool dfsIterative(vector<vector<int>>& grid, int sx, int sy, int ex, int ey, vector<pair<int, int>>& path) {
    int rows = grid.size(), cols = grid[0].size();
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    // 栈中存储节点及其在路径中的索引（或直接存储路径历史）
    stack<pair<int, int>> stk;
    vector<vector<pair<int, int>>> parent(rows, vector<pair<int, int>>(cols, {-1, -1})); // 记录父节点用于重建路径
    
    stk.push({sx, sy});
    visited[sx][sy] = true;
    
    while (!stk.empty()) {
        auto [x, y] = stk.top();
        stk.pop();
        
        if (x == ex && y == ey) {
            // 重建路径：从终点回溯到起点
            path.clear();
            int curX = ex, curY = ey;
            while (curX != -1 && curY != -1) {
                path.push_back({curX, curY});
                auto [pX, pY] = parent[curX][curY];
                curX = pX;
                curY = pY;
            }
            reverse(path.begin(), path.end());
            return true;
        }
        
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && 
                grid[nx][ny] == 0 && !visited[nx][ny]) {
                visited[nx][ny] = true;
                parent[nx][ny] = {x, y}; // 记录父节点
                stk.push({nx, ny});
            }
        }
    }
    return false;
}

// main函数类似，调用dfsIterative即可
```

###  DFS 特性与应用场景

| 特性/场景      | 说明                                                         |
| :------------- | :----------------------------------------------------------- |
| **完备性**     | 如果路径存在，DFS**一定能找到**一条路径（但未必是最短路径）。 |
| **非最短路径** | DFS找到的路径**不一定是最短的**。如果需要最短路径，应考虑使用广度优先搜索（BFS）。 |
| **内存效率**   | 相对于BFS，DFS的内存消耗通常较低，因为它不需要存储所有待探索的节点。 |
| **适用场景**   | 迷宫求解、连通性检测、拓扑排序、图的环路检测等。             |

## BFS

```
#include <iostream>
#include <queue>
#include <vector>
#include <utility> // for pair
#include <algorithm>
#include <climits>

using namespace std;

// 定义方向数组：上、下、左、右四个主要方向
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};

// 使用 BFS 搜索迷宫最短路径
// maze: 迷宫矩阵, 0表示可通行，1表示障碍物
// start: 起点坐标
// end: 终点坐标
// 返回从起点到终点的最短路径长度，无法到达则返回-1，并通过引用参数返回路径信息
int bfsMaze(vector<vector<int>>& maze, pair<int, int> start, pair<int, int> end, vector<pair<int, int>>& finalPath) {
    int rows = maze.size();
    if (rows == 0) return -1;
    int cols = maze[0].size();
    
    // 创建访问标记矩阵和记录到达每个点的前驱节点坐标的矩阵
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    vector<vector<pair<int, int>>> predecessor(rows, vector<pair<int, int>>(cols, {-1, -1})); // 用于回溯路径
    
    queue<pair<int, int>> q;
    q.push(start);
    visited[start.first][start.second] = true;
    int steps = 0; // 记录步数（即路径长度）
    bool found = false;
    
    while (!q.empty()) {
        int levelSize = q.size();
        for (int i = 0; i < levelSize; ++i) {
            auto current = q.front();
            q.pop();
            
            int x = current.first;
            int y = current.second;
            
            // 检查是否到达终点
            if (x == end.first && y == end.second) {
                found = true;
                // 回溯构建路径
                finalPath.clear();
                pair<int, int> curNode = end;
                while (curNode != make_pair(-1, -1) && curNode != start) { // 回溯直到起点或无效节点
                    finalPath.push_back(curNode);
                    curNode = predecessor[curNode.first][curNode.second];
                }
                finalPath.push_back(start);
                reverse(finalPath.begin(), finalPath.end());
                return steps; // 返回最短路径的步数
            }
            
            // 探索四个方向
            for (int dir = 0; dir < 4; ++dir) {
                int nx = x + dx[dir];
                int ny = y + dy[dir];
                
                // 检查新坐标是否有效且可通行且未被访问
                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && maze[nx][ny] == 0 && !visited[nx][ny]) {
                    visited[nx][ny] = true;
                    predecessor[nx][ny] = {x, y}; // 记录前驱节点，用于回溯
                    q.push({nx, ny});
                }
            }
        }
        steps++; // 处理完一层，步数加1
    }
    
    return -1; // 无法到达终点
}

int main() {
    // 示例迷宫：0表示通道，1表示墙壁
    vector<vector<int>> maze = {
        {0, 1, 0, 0, 0},
        {0, 1, 0, 1, 0},
        {0, 0, 0, 0, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0}
    };
    
    pair<int, int> start = {0, 0}; // 起点 (0,0)
    pair<int, int> end = {4, 4};   // 终点 (4,4)
    
    vector<pair<int, int>> path; // 存储找到的路径
    
    int shortestPathLength = bfsMaze(maze, start, end, path);
    
    if (shortestPathLength != -1) {
        cout << "找到路径！最短路径长度为: " << shortestPathLength << endl;
        cout << "路径坐标为: ";
        for (size_t i = 0; i < path.size(); ++i) {
            cout << "(" << path[i].first << ", " << path[i].second << ")";
            if (i != path.size() - 1) cout << " -> ";
        }
        cout << endl;
    } else {
        cout << "无法从起点到达终点！" << endl;
    }
    
    return 0;
}
```

### BFS 路径搜索关键点

1. BFS 与最短路径：BFS 按层扩散的特性保证了当它第一次遇到终点时，**所走过的步数就是最短路径长度**。这在无权图（或像本例中所有移动代价相同的网格）中成立。
2. 路径回溯：BFS 本身在搜索过程中并不自然记录完整路径。为了输出路径，需要一个额外的数据结构（如上面的predecessor矩阵）来记录每个节点是由哪个前驱节点访问的。找到终点后，从终点开始，逆着前驱节点回溯直到起点，就能得到完整的最短路径。
3. 方向向量：dx和dy数组定义了移动方向。上面的例子使用了四方向（上、下、左、右），你也可以扩展为八方向（包括对角线）。
4. **访问标记**：`visited` 数组至关重要，它防止了重复访问同一个节点，避免了无限循环，也是 BFS 与 DFS 的一个重要区别。

## Dijkstra算法

Dijkstra算法是计算机科学中非常经典的最短路径算法，由荷兰计算机科学家Edsger W. Dijkstra于1956年提出。它用于在**加权图**（有向或无向）中，找到从单个**源点**（起点）到所有其他节点的**最短路径**。这里的“权重”通常表示距离、成本或时间等概念

### 算法核心思想与特点

Dijkstra算法采用**贪心策略**（Greedy Algorithm）。其核心思想是：

1. **逐步扩展**：从源点开始，逐步确定到其他各顶点的最短路径。
2. **选择当前最短路径**：在每一步中，从未确定最短路径的节点中选择一个距离源点最近的节点，认定其当前距离即为最短距离。
3. 更新邻居距离：然后更新该节点所有邻居节点的当前最短距离。

算法有两个关键特点：

- 非负权重：要求图中所有边的权重均为非负值。若存在负权边，算法可能无法得出正确结果。
- **单源路径**：解决的是单源最短路径问题。

### 算法步骤详解

![DijkStra](pic\DijkStra.png)

### 算法实现

```
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

// 边的结构：目标节点和权重
struct Edge {
    int to;
    int weight;
    Edge(int t, int w) : to(t), weight(w) {}
};

// Dijkstra算法实现
void dijkstra(const vector<vector<Edge>>& graph, int start, vector<int>& distances, vector<int>& predecessors) {
    int n = graph.size();
    distances.assign(n, INT_MAX);  // 初始化距离为无穷大
    predecessors.assign(n, -1);    // 初始化前驱节点为-1
    distances[start] = 0;          // 起点到自身的距离为0
    
    // 优先队列：(距离, 节点)，按距离从小到大排序
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int current_dist = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        
        // 如果当前距离大于已知最短距离，则跳过
        if (current_dist > distances[u]) {
            continue;
        }
        
        // 遍历所有邻接节点
        for (const Edge& edge : graph[u]) {
            int v = edge.to;
            int weight = edge.weight;
            
            // 松弛操作：如果找到更短的路径
            if (distances[v] > distances[u] + weight) {
                distances[v] = distances[u] + weight;
                predecessors[v] = u;
                pq.push({distances[v], v});
            }
        }
    }
}

// 打印从起点到目标节点的最短路径
void printPath(int target, const vector<int>& predecessors) {
    if (predecessors[target] == -1) {
        cout << target;
        return;
    }
    printPath(predecessors[target], predecessors);
    cout << " -> " << target;
}

int main() {
    // 构建图：节点0到4的有向图
    int n = 5;  // 节点数量
    vector<vector<Edge>> graph(n);
    
    // 添加边
    graph[0].emplace_back(1, 4);   // 0->1，权重4
    graph[0].emplace_back(2, 1);   // 0->2，权重1
    graph[2].emplace_back(1, 2);   // 2->1，权重2
    graph[2].emplace_back(3, 5);   // 2->3，权重5
    graph[1].emplace_back(3, 1);   // 1->3，权重1
    graph[3].emplace_back(4, 3);   // 3->4，权重3
    
    int start = 0;  // 起点
    vector<int> distances, predecessors;
    
    // 运行Dijkstra算法
    dijkstra(graph, start, distances, predecessors);
    
    // 输出结果
    cout << "从节点" << start << "到各节点的最短距离：" << endl;
    for (int i = 0; i < n; ++i) {
        if (distances[i] == INT_MAX) {
            cout << "节点" << start << "到节点" << i << "不可达" << endl;
        } else {
            cout << "节点" << start << "到节点" << i << "的最短距离为：" << distances[i] 
                 << "，路径为：";
            printPath(i, predecessors);
            cout << endl;
        }
    }
    
    return 0;
}

输出：
从节点0到各节点的最短距离：
节点0到节点0的最短距离为：0，路径为：0
节点0到节点1的最短距离为：3，路径为：0 -> 2 -> 1
节点0到节点2的最短距离为：1，路径为：0 -> 2
节点0到节点3的最短距离为：4，路径为：0 -> 2 -> 1 -> 3
节点0到节点4的最短距离为：7，路径为：0 -> 2 -> 1 -> 3 -> 4
```

### 优缺点

**优点**：

- 能保证找到最短路径：在非负权图中，可以保证找到源点到所有可达节点的最短路径。
- **效率相对较高**：特别是使用优先队列优化后，在稀疏图中表现良好。

**缺点**：

- 无法处理负权边：如果图中存在负权边，Dijkstra算法可能无法得出正确结果。
- **盲目搜索**：与A*等启发式算法相比，缺乏方向性，可能会探索许多不必要的节点。**权重为1时，就是BFS**。

## A*算法

### 基本原理

A * 算法通过维护每个节点的两个代价来决定搜索方向：

- `g(n)`：从起点到当前节点`n`的实际代价
- `h(n)`：从当前节点`n`到目标节点的估计代价（启发式函数）
- `f(n) = g(n) + h(n)`：节点`n`的总代价，A * 算法总是优先扩展`f(n)`最小的节点

常用的启发式函数有：

- 曼哈顿距离（适合网格地图）：`|x1-x2| + |y1-y2|`
- 欧几里得距离：`√[(x1-x2)² + (y1-y2)²]`

### 算法实现

```C++
#include <iostream>
#include <vector>
#include <queue>
#include <cmath>
#include <algorithm>

using namespace std;

// 定义网格中的节点
struct Node {
    int x, y;          // 坐标
    int g;             // 从起点到当前节点的成本
    int h;             // 从当前节点到目标的估计成本
    Node* parent;      // 父节点指针
    
    Node(int x_, int y_) : x(x_), y(y_), g(0), h(0), parent(nullptr) {}
    
    // f(n) = g(n) + h(n)
    int f() const {
        return g + h;
    }
};

// 比较函数，用于优先队列
struct CompareNode {
    bool operator()(Node* a, Node* b) {
        return a->f() > b->f(); // 小的f值优先
    }
};

// 计算启发函数 (曼哈顿距离)
int heuristic(int x1, int y1, int x2, int y2) {
    return abs(x1 - x2) + abs(y1 - y2);
}

// 检查节点是否在网格范围内
bool isInsideGrid(int x, int y, int rows, int cols) {
    return (x >= 0 && x < rows && y >= 0 && y < cols);
}

// 检查节点是否可通行且未被访问
bool isPassable(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    return (grid[x][y] == 0 && !visited[x][y]);
}

// A*算法实现
vector<pair<int, int>> aStar(const vector<vector<int>>& grid, 
                            int startX, int startY, 
                            int goalX, int goalY) {
    int rows = grid.size();
    if (rows == 0) return {};
    int cols = grid[0].size();
    
    // 方向数组：8个可能的移动方向（上下左右及四个对角线）
    int dirs[8][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1},
                      {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};
    
    // 初始化起点和目标点
    Node* start = new Node(startX, startY);
    Node* goal = new Node(goalX, goalY);
    
    // 优先队列（开放列表）
    priority_queue<Node*, vector<Node*>, CompareNode> openList;
    
    // 已访问节点（关闭列表）
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    
    // 将起点加入开放列表
    openList.push(start);
    
    // A*主循环
    while (!openList.empty()) {
        // 获取f值最小的节点
        Node* current = openList.top();
        openList.pop();
        
        // 如果到达目标点，回溯路径
        if (current->x == goal->x && current->y == goal->y) {
            vector<pair<int, int>> path;
            while (current != nullptr) {
                path.push_back({current->x, current->y});
                current = current->parent;
            }
            reverse(path.begin(), path.end());
            
            // 清理内存
            delete goal;
            while (!openList.empty()) {
                Node* node = openList.top();
                openList.pop();
                delete node;
            }
            
            return path;
        }
        
        // 标记当前节点为已访问
        visited[current->x][current->y] = true;
        
        // 探索所有相邻节点
        for (int i = 0; i < 8; i++) {
            int newX = current->x + dirs[i][0];
            int newY = current->y + dirs[i][1];
            
            // 检查新位置是否有效
            if (isInsideGrid(newX, newY, rows, cols) && isPassable(grid, visited, newX, newY)) {
                // 创建新节点
                Node* neighbor = new Node(newX, newY);
                neighbor->parent = current;
                neighbor->g = current->g + 1; // 假设每步成本为1
                neighbor->h = heuristic(newX, newY, goal->x, goal->y);
                
                // 将新节点加入开放列表
                openList.push(neighbor);
            }
        }
    }
    
    // 如果没有找到路径
    delete start;
    delete goal;
    return {};
}

int main() {
    // 示例网格地图：0表示可通行，1表示障碍物
    vector<vector<int>> grid = {
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    };
    
    // 起点和目标点坐标
    int startX = 0, startY = 0;
    int goalX = 9, goalY = 9;
    
    // 运行A*算法
    vector<pair<int, int>> path = aStar(grid, startX, startY, goalX, goalY);
    
    // 输出结果
    if (path.empty()) {
        cout << "没有找到路径！" << endl;
    } else {
        cout << "找到路径，长度为: " << path.size() << endl;
        cout << "路径如下: " << endl;
        for (const auto& p : path) {
            cout << "(" << p.first << ", " << p.second << ") ";
            // 在网格上标记路径
            grid[p.first][p.second] = 2;
        }
        cout << endl << endl;
        
        // 打印带路径的网格
        cout << "带路径的网格 (2表示路径):" << endl;
        for (const auto& row : grid) {
            for (int cell : row) {
                if (cell == 1) cout << "# "; // 障碍物
                else if (cell == 2) cout << "* "; // 路径
                else cout << ". "; // 可通行区域
            }
            cout << endl;
        }
    }
    
    return 0;
}

输出：
找到路径，长度为: 11
路径如下: 
(0, 0) (1, 1) (2, 2) (3, 3) (4, 3) (5, 4) (6, 5) (7, 6) (8, 7) (9, 8) (9, 9) 
带路径的网格 (2表示路径):
* . . . # . . . . . 
. * . . # . . . . . 
. . * . # . . . . . 
. . . * # . . . . . 
. . . * # . . . . . 
. . . . * . . . . . 
. . . . # * . . . . 
. . . . # . * . . . 
. . . . # . . * . . 
. . . . . . . . * * 
```

## 总结

|       特性       |        DFS (深度优先搜索)        |      BFS (广度优先搜索)      |       Dijkstra (迪杰斯特拉算法)       |         A* (A-Star算法)          |
| :--------------: | :------------------------------: | :--------------------------: | :-----------------------------------: | :------------------------------: |
|   **核心思想**   |       一条路走到黑，再回溯       |      按层扩散，稳扎稳打      |    优先选择当前累积代价最小的路径     |  综合累积代价和到目标的估计代价  |
|   **数据结构**   |        栈 (Stack) / 递归         |         队列 (Queue)         |       优先队列 (Priority Queue)       |    优先队列 (Priority Queue)     |
|   **是否最优**   |        否（除非额外处理）        |     **是**（在无权图中）     |       **是**（在带权非负图中）        |    **是**（启发函数可采纳时）    |
|  **时间复杂度**  |         O(\|V\|+ \|E\|)          |       O(\|V\|+ \|E\|)        | O((\|V\|+\|E\|) log \|V\|) (优先队列) | 取决于启发函数，最坏情况 O(b^d)  |
|  **空间复杂度**  |             O(\|V\|)             |           O(\|V\|)           |               O(\|V\|)                |             O(\|V\|)             |
| **主要适用场景** | 拓扑排序、连通性检测、寻找所有解 | 无权图最短路径、层次关系分析 |   带权非负图最短路径（如路由协议）    | 路径规划（如游戏AI、机器人导航） |

### 算法简要说明

1. **DFS (深度优先搜索)**：像探险家深入迷宫，先一条路走到底，再回溯尝试其他岔路。**不保证找到最短路径**，但**内存消耗相对较低**（通常与树的高度成正比）。适合需要**遍历所有可能性**的场景，如拓扑排序、连通性检测或求解排列组合问题。

2. **BFS (广度优先搜索)**：像水波扩散，层层推进，总是先访问离起点最近的节点。在**无权图**中能**保证找到最短路径**。缺点是**内存消耗较大**（与树的宽度成正比），因为需要存储每一层的节点。适合社交网络层级分析、迷宫最短路径等。

3. **Dijkstra算法**：可以看作是BFS在**带权图**（边的权重非负）上的扩展。它通过**优先队列**，总是优先扩展从起点到当前点**累积代价（g(n)）最小**的节点，从而保证在非负权图中找到最短路径。常用于网络路由、地图导航等。

4. **A\*算法**：在Dijkstra的基础上，增加了一个**启发函数（h(n)）**来估计当前点到目标点的代价，其评估函数为 **f(n) = g(n) + h(n)**（g(n)是实际代价，h(n)是估计代价）*。这样搜索会更有方向性，效率通常远高于Dijkstra

   。*只要启发函数 h(n) 是可采纳的（即从不高估实际代价），A*就能保证找到**最短路径**。广泛应用于游戏AI、机器人路径规划等领域。

###  如何选择算法

选择算法时，考虑以下几点：

- **图是否有权重**：如果图**没有权重**，追求最短路径可选用**BFS**；若只需连通性或遍历所有路径，**DFS**可能更省内存。如果图**有权重**且**权重非负**，需要最短路径，**Dijkstra**是可靠选择。
- **是否需要最优解**：追求**最短路径**或**最小代价**时，BFS（无权）、Dijkstra（带权非负）、A*（启发函数可采纳）都可以保证。**若解是否存在比是否最优更重要，或需要所有可能解，DFS更合适**。
- **是否有启发信息**：如果存在良好的启发函数来估计到目标的距离（如地图上的直线距离），**A\*** 通常能**显著提高搜索效率**。
- **空间与时间效率的权衡**：**DFS**通常空间效率较高，但可能“误入歧途”；**BFS**和**Dijkstra**保证最优但空间开销可能较大；**A\*** 在好的启发函数下可以兼顾效率和最优性

