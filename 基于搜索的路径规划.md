# 基于搜索的路径规划

## DFS

### 递归版本

```C++
#include <iostream>
#include <vector>
#include <utility> // for pair

using namespace std;

// 定义方向：上、右、下、左（顺时针方向）
const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

// DFS递归函数
bool dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, 
         int x, int y, int ex, int ey, vector<pair<int, int>>& path) {
    // 检查是否超出边界、是否是障碍物、或是否已访问
    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || 
        grid[x][y] == 1 || visited[x][y]) {
        return false;
    }
    
    // 标记当前节点为已访问，并加入路径
    visited[x][y] = true;
    path.push_back({x, y});
    
    // 如果到达终点，返回成功
    if (x == ex && y == ey) {
        return true;
    }
    
    // 向四个方向递归搜索
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (dfs(grid, visited, nx, ny, ex, ey, path)) {
            return true; // 找到路径，立即返回
        }
    }
    
    // 如果所有方向都找不到路径，回溯：从路径中移除当前节点并返回false
    path.pop_back();
    return false;
}

int main() {
    // 示例网格：0可走，1障碍物
    vector<vector<int>> grid = {
        {0, 1, 0, 0, 0},
        {0, 1, 0, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 0, 0, 0},
        {0, 0, 0, 1, 0}
    };
    
    int sx = 0, sy = 0; // 起点坐标
    int ex = 4, ey = 4; // 终点坐标
    
    // 初始化访问标记矩阵
    vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));
    vector<pair<int, int>> path; // 存储找到的路径
    
    // 调用DFS搜索
    bool found = dfs(grid, visited, sx, sy, ex, ey, path);
    
    if (found) {
        cout << "找到路径：";
        for (auto& p : path) {
            cout << "(" << p.first << "," << p.second << ") ";
        }
        cout << endl;
    } else {
        cout << "未找到路径！" << endl;
    }
    
    return 0;
}
```

### 非递归（迭代）版本（使用显式栈）

对于深度较大的图，为了避免递归栈溢出，可以使用显式栈来实现DFS：

```C++
#include <iostream>
#include <vector>
#include <stack>
#include <utility>

using namespace std;

const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

bool dfsIterative(vector<vector<int>>& grid, int sx, int sy, int ex, int ey, vector<pair<int, int>>& path) {
    int rows = grid.size(), cols = grid[0].size();
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    // 栈中存储节点及其在路径中的索引（或直接存储路径历史）
    stack<pair<int, int>> stk;
    vector<vector<pair<int, int>>> parent(rows, vector<pair<int, int>>(cols, {-1, -1})); // 记录父节点用于重建路径
    
    stk.push({sx, sy});
    visited[sx][sy] = true;
    
    while (!stk.empty()) {
        auto [x, y] = stk.top();
        stk.pop();
        
        if (x == ex && y == ey) {
            // 重建路径：从终点回溯到起点
            path.clear();
            int curX = ex, curY = ey;
            while (curX != -1 && curY != -1) {
                path.push_back({curX, curY});
                auto [pX, pY] = parent[curX][curY];
                curX = pX;
                curY = pY;
            }
            reverse(path.begin(), path.end());
            return true;
        }
        
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && 
                grid[nx][ny] == 0 && !visited[nx][ny]) {
                visited[nx][ny] = true;
                parent[nx][ny] = {x, y}; // 记录父节点
                stk.push({nx, ny});
            }
        }
    }
    return false;
}

// main函数类似，调用dfsIterative即可
```

###  DFS 特性与应用场景

| 特性/场景      | 说明                                                         |
| :------------- | :----------------------------------------------------------- |
| **完备性**     | 如果路径存在，DFS**一定能找到**一条路径（但未必是最短路径）。 |
| **非最短路径** | DFS找到的路径**不一定是最短的**。如果需要最短路径，应考虑使用广度优先搜索（BFS）。 |
| **内存效率**   | 相对于BFS，DFS的内存消耗通常较低，因为它不需要存储所有待探索的节点。 |
| **适用场景**   | 迷宫求解、连通性检测、拓扑排序、图的环路检测等。             |

## BFS

```
#include <iostream>
#include <queue>
#include <vector>
#include <utility> // for pair
#include <algorithm>
#include <climits>

using namespace std;

// 定义方向数组：上、下、左、右四个主要方向
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};

// 使用 BFS 搜索迷宫最短路径
// maze: 迷宫矩阵, 0表示可通行，1表示障碍物
// start: 起点坐标
// end: 终点坐标
// 返回从起点到终点的最短路径长度，无法到达则返回-1，并通过引用参数返回路径信息
int bfsMaze(vector<vector<int>>& maze, pair<int, int> start, pair<int, int> end, vector<pair<int, int>>& finalPath) {
    int rows = maze.size();
    if (rows == 0) return -1;
    int cols = maze[0].size();
    
    // 创建访问标记矩阵和记录到达每个点的前驱节点坐标的矩阵
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    vector<vector<pair<int, int>>> predecessor(rows, vector<pair<int, int>>(cols, {-1, -1})); // 用于回溯路径
    
    queue<pair<int, int>> q;
    q.push(start);
    visited[start.first][start.second] = true;
    int steps = 0; // 记录步数（即路径长度）
    bool found = false;
    
    while (!q.empty()) {
        int levelSize = q.size();
        for (int i = 0; i < levelSize; ++i) {
            auto current = q.front();
            q.pop();
            
            int x = current.first;
            int y = current.second;
            
            // 检查是否到达终点
            if (x == end.first && y == end.second) {
                found = true;
                // 回溯构建路径
                finalPath.clear();
                pair<int, int> curNode = end;
                while (curNode != make_pair(-1, -1) && curNode != start) { // 回溯直到起点或无效节点
                    finalPath.push_back(curNode);
                    curNode = predecessor[curNode.first][curNode.second];
                }
                finalPath.push_back(start);
                reverse(finalPath.begin(), finalPath.end());
                return steps; // 返回最短路径的步数
            }
            
            // 探索四个方向
            for (int dir = 0; dir < 4; ++dir) {
                int nx = x + dx[dir];
                int ny = y + dy[dir];
                
                // 检查新坐标是否有效且可通行且未被访问
                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && maze[nx][ny] == 0 && !visited[nx][ny]) {
                    visited[nx][ny] = true;
                    predecessor[nx][ny] = {x, y}; // 记录前驱节点，用于回溯
                    q.push({nx, ny});
                }
            }
        }
        steps++; // 处理完一层，步数加1
    }
    
    return -1; // 无法到达终点
}

int main() {
    // 示例迷宫：0表示通道，1表示墙壁
    vector<vector<int>> maze = {
        {0, 1, 0, 0, 0},
        {0, 1, 0, 1, 0},
        {0, 0, 0, 0, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0}
    };
    
    pair<int, int> start = {0, 0}; // 起点 (0,0)
    pair<int, int> end = {4, 4};   // 终点 (4,4)
    
    vector<pair<int, int>> path; // 存储找到的路径
    
    int shortestPathLength = bfsMaze(maze, start, end, path);
    
    if (shortestPathLength != -1) {
        cout << "找到路径！最短路径长度为: " << shortestPathLength << endl;
        cout << "路径坐标为: ";
        for (size_t i = 0; i < path.size(); ++i) {
            cout << "(" << path[i].first << ", " << path[i].second << ")";
            if (i != path.size() - 1) cout << " -> ";
        }
        cout << endl;
    } else {
        cout << "无法从起点到达终点！" << endl;
    }
    
    return 0;
}
```

### BFS 路径搜索关键点

1. BFS 与最短路径：BFS 按层扩散的特性保证了当它第一次遇到终点时，**所走过的步数就是最短路径长度**。这在无权图（或像本例中所有移动代价相同的网格）中成立。
2. 路径回溯：BFS 本身在搜索过程中并不自然记录完整路径。为了输出路径，需要一个额外的数据结构（如上面的predecessor矩阵）来记录每个节点是由哪个前驱节点访问的。找到终点后，从终点开始，逆着前驱节点回溯直到起点，就能得到完整的最短路径。
3. 方向向量：dx和dy数组定义了移动方向。上面的例子使用了四方向（上、下、左、右），你也可以扩展为八方向（包括对角线）。
4. **访问标记**：`visited` 数组至关重要，它防止了重复访问同一个节点，避免了无限循环，也是 BFS 与 DFS 的一个重要区别。

## Dijkstra算法

Dijkstra算法是计算机科学中非常经典的最短路径算法，由荷兰计算机科学家Edsger W. Dijkstra于1956年提出。它用于在**加权图**（有向或无向）中，找到从单个**源点**（起点）到所有其他节点的**最短路径**。这里的“权重”通常表示距离、成本或时间等概念

### 算法核心思想与特点

Dijkstra算法采用**贪心策略**（Greedy Algorithm）。其核心思想是：

1. **逐步扩展**：从源点开始，逐步确定到其他各顶点的最短路径。
2. **选择当前最短路径**：在每一步中，从未确定最短路径的节点中选择一个距离源点最近的节点，认定其当前距离即为最短距离。
3. 更新邻居距离：然后更新该节点所有邻居节点的当前最短距离。

算法有两个关键特点：

- 非负权重：要求图中所有边的权重均为非负值。若存在负权边，算法可能无法得出正确结果。
- **单源路径**：解决的是单源最短路径问题。

### 算法步骤详解

![DijkStra](pic\DijkStra.png)

### 算法实现

```
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

// 边的结构：目标节点和权重
struct Edge {
    int to;
    int weight;
    Edge(int t, int w) : to(t), weight(w) {}
};

// Dijkstra算法实现
void dijkstra(const vector<vector<Edge>>& graph, int start, vector<int>& distances, vector<int>& predecessors) {
    int n = graph.size();
    distances.assign(n, INT_MAX);  // 初始化距离为无穷大
    predecessors.assign(n, -1);    // 初始化前驱节点为-1
    distances[start] = 0;          // 起点到自身的距离为0
    
    // 优先队列：(距离, 节点)，按距离从小到大排序
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int current_dist = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        
        // 如果当前距离大于已知最短距离，则跳过
        if (current_dist > distances[u]) {
            continue;
        }
        
        // 遍历所有邻接节点
        for (const Edge& edge : graph[u]) {
            int v = edge.to;
            int weight = edge.weight;
            
            // 松弛操作：如果找到更短的路径
            if (distances[v] > distances[u] + weight) {
                distances[v] = distances[u] + weight;
                predecessors[v] = u;
                pq.push({distances[v], v});
            }
        }
    }
}

// 打印从起点到目标节点的最短路径
void printPath(int target, const vector<int>& predecessors) {
    if (predecessors[target] == -1) {
        cout << target;
        return;
    }
    printPath(predecessors[target], predecessors);
    cout << " -> " << target;
}

int main() {
    // 构建图：节点0到4的有向图
    int n = 5;  // 节点数量
    vector<vector<Edge>> graph(n);
    
    // 添加边
    graph[0].emplace_back(1, 4);   // 0->1，权重4
    graph[0].emplace_back(2, 1);   // 0->2，权重1
    graph[2].emplace_back(1, 2);   // 2->1，权重2
    graph[2].emplace_back(3, 5);   // 2->3，权重5
    graph[1].emplace_back(3, 1);   // 1->3，权重1
    graph[3].emplace_back(4, 3);   // 3->4，权重3
    
    int start = 0;  // 起点
    vector<int> distances, predecessors;
    
    // 运行Dijkstra算法
    dijkstra(graph, start, distances, predecessors);
    
    // 输出结果
    cout << "从节点" << start << "到各节点的最短距离：" << endl;
    for (int i = 0; i < n; ++i) {
        if (distances[i] == INT_MAX) {
            cout << "节点" << start << "到节点" << i << "不可达" << endl;
        } else {
            cout << "节点" << start << "到节点" << i << "的最短距离为：" << distances[i] 
                 << "，路径为：";
            printPath(i, predecessors);
            cout << endl;
        }
    }
    
    return 0;
}

输出：
从节点0到各节点的最短距离：
节点0到节点0的最短距离为：0，路径为：0
节点0到节点1的最短距离为：3，路径为：0 -> 2 -> 1
节点0到节点2的最短距离为：1，路径为：0 -> 2
节点0到节点3的最短距离为：4，路径为：0 -> 2 -> 1 -> 3
节点0到节点4的最短距离为：7，路径为：0 -> 2 -> 1 -> 3 -> 4
```

### 优缺点

**优点**：

- 能保证找到最短路径：在非负权图中，可以保证找到源点到所有可达节点的最短路径。
- **效率相对较高**：特别是使用优先队列优化后，在稀疏图中表现良好。

**缺点**：

- 无法处理负权边：如果图中存在负权边，Dijkstra算法可能无法得出正确结果。
- **盲目搜索**：与A*等启发式算法相比，缺乏方向性，可能会探索许多不必要的节点。**权重为1时，就是BFS**。
