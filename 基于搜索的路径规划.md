# 基于搜索的路径规划

## DFS

### 递归版本

```C++
#include <iostream>
#include <vector>
#include <utility> // for pair

using namespace std;

// 定义方向：上、右、下、左（顺时针方向）
const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

// DFS递归函数
bool dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, 
         int x, int y, int ex, int ey, vector<pair<int, int>>& path) {
    // 检查是否超出边界、是否是障碍物、或是否已访问
    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || 
        grid[x][y] == 1 || visited[x][y]) {
        return false;
    }
    
    // 标记当前节点为已访问，并加入路径
    visited[x][y] = true;
    path.push_back({x, y});
    
    // 如果到达终点，返回成功
    if (x == ex && y == ey) {
        return true;
    }
    
    // 向四个方向递归搜索
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (dfs(grid, visited, nx, ny, ex, ey, path)) {
            return true; // 找到路径，立即返回
        }
    }
    
    // 如果所有方向都找不到路径，回溯：从路径中移除当前节点并返回false
    path.pop_back();
    return false;
}

int main() {
    // 示例网格：0可走，1障碍物
    vector<vector<int>> grid = {
        {0, 1, 0, 0, 0},
        {0, 1, 0, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 0, 0, 0},
        {0, 0, 0, 1, 0}
    };
    
    int sx = 0, sy = 0; // 起点坐标
    int ex = 4, ey = 4; // 终点坐标
    
    // 初始化访问标记矩阵
    vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));
    vector<pair<int, int>> path; // 存储找到的路径
    
    // 调用DFS搜索
    bool found = dfs(grid, visited, sx, sy, ex, ey, path);
    
    if (found) {
        cout << "找到路径：";
        for (auto& p : path) {
            cout << "(" << p.first << "," << p.second << ") ";
        }
        cout << endl;
    } else {
        cout << "未找到路径！" << endl;
    }
    
    return 0;
}
```

### 非递归（迭代）版本（使用显式栈）

对于深度较大的图，为了避免递归栈溢出，可以使用显式栈来实现DFS：

```C++
#include <iostream>
#include <vector>
#include <stack>
#include <utility>

using namespace std;

const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

bool dfsIterative(vector<vector<int>>& grid, int sx, int sy, int ex, int ey, vector<pair<int, int>>& path) {
    int rows = grid.size(), cols = grid[0].size();
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    // 栈中存储节点及其在路径中的索引（或直接存储路径历史）
    stack<pair<int, int>> stk;
    vector<vector<pair<int, int>>> parent(rows, vector<pair<int, int>>(cols, {-1, -1})); // 记录父节点用于重建路径
    
    stk.push({sx, sy});
    visited[sx][sy] = true;
    
    while (!stk.empty()) {
        auto [x, y] = stk.top();
        stk.pop();
        
        if (x == ex && y == ey) {
            // 重建路径：从终点回溯到起点
            path.clear();
            int curX = ex, curY = ey;
            while (curX != -1 && curY != -1) {
                path.push_back({curX, curY});
                auto [pX, pY] = parent[curX][curY];
                curX = pX;
                curY = pY;
            }
            reverse(path.begin(), path.end());
            return true;
        }
        
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && 
                grid[nx][ny] == 0 && !visited[nx][ny]) {
                visited[nx][ny] = true;
                parent[nx][ny] = {x, y}; // 记录父节点
                stk.push({nx, ny});
            }
        }
    }
    return false;
}

// main函数类似，调用dfsIterative即可
```

###  DFS 特性与应用场景

| 特性/场景      | 说明                                                         |
| :------------- | :----------------------------------------------------------- |
| **完备性**     | 如果路径存在，DFS**一定能找到**一条路径（但未必是最短路径）。 |
| **非最短路径** | DFS找到的路径**不一定是最短的**。如果需要最短路径，应考虑使用广度优先搜索（BFS）。 |
| **内存效率**   | 相对于BFS，DFS的内存消耗通常较低，因为它不需要存储所有待探索的节点。 |
| **适用场景**   | 迷宫求解、连通性检测、拓扑排序、图的环路检测等。             |

## BFS

```
#include <iostream>
#include <queue>
#include <vector>
#include <utility> // for pair
#include <algorithm>
#include <climits>

using namespace std;

// 定义方向数组：上、下、左、右四个主要方向
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};

// 使用 BFS 搜索迷宫最短路径
// maze: 迷宫矩阵, 0表示可通行，1表示障碍物
// start: 起点坐标
// end: 终点坐标
// 返回从起点到终点的最短路径长度，无法到达则返回-1，并通过引用参数返回路径信息
int bfsMaze(vector<vector<int>>& maze, pair<int, int> start, pair<int, int> end, vector<pair<int, int>>& finalPath) {
    int rows = maze.size();
    if (rows == 0) return -1;
    int cols = maze[0].size();
    
    // 创建访问标记矩阵和记录到达每个点的前驱节点坐标的矩阵
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    vector<vector<pair<int, int>>> predecessor(rows, vector<pair<int, int>>(cols, {-1, -1})); // 用于回溯路径
    
    queue<pair<int, int>> q;
    q.push(start);
    visited[start.first][start.second] = true;
    int steps = 0; // 记录步数（即路径长度）
    bool found = false;
    
    while (!q.empty()) {
        int levelSize = q.size();
        for (int i = 0; i < levelSize; ++i) {
            auto current = q.front();
            q.pop();
            
            int x = current.first;
            int y = current.second;
            
            // 检查是否到达终点
            if (x == end.first && y == end.second) {
                found = true;
                // 回溯构建路径
                finalPath.clear();
                pair<int, int> curNode = end;
                while (curNode != make_pair(-1, -1) && curNode != start) { // 回溯直到起点或无效节点
                    finalPath.push_back(curNode);
                    curNode = predecessor[curNode.first][curNode.second];
                }
                finalPath.push_back(start);
                reverse(finalPath.begin(), finalPath.end());
                return steps; // 返回最短路径的步数
            }
            
            // 探索四个方向
            for (int dir = 0; dir < 4; ++dir) {
                int nx = x + dx[dir];
                int ny = y + dy[dir];
                
                // 检查新坐标是否有效且可通行且未被访问
                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && maze[nx][ny] == 0 && !visited[nx][ny]) {
                    visited[nx][ny] = true;
                    predecessor[nx][ny] = {x, y}; // 记录前驱节点，用于回溯
                    q.push({nx, ny});
                }
            }
        }
        steps++; // 处理完一层，步数加1
    }
    
    return -1; // 无法到达终点
}

int main() {
    // 示例迷宫：0表示通道，1表示墙壁
    vector<vector<int>> maze = {
        {0, 1, 0, 0, 0},
        {0, 1, 0, 1, 0},
        {0, 0, 0, 0, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0}
    };
    
    pair<int, int> start = {0, 0}; // 起点 (0,0)
    pair<int, int> end = {4, 4};   // 终点 (4,4)
    
    vector<pair<int, int>> path; // 存储找到的路径
    
    int shortestPathLength = bfsMaze(maze, start, end, path);
    
    if (shortestPathLength != -1) {
        cout << "找到路径！最短路径长度为: " << shortestPathLength << endl;
        cout << "路径坐标为: ";
        for (size_t i = 0; i < path.size(); ++i) {
            cout << "(" << path[i].first << ", " << path[i].second << ")";
            if (i != path.size() - 1) cout << " -> ";
        }
        cout << endl;
    } else {
        cout << "无法从起点到达终点！" << endl;
    }
    
    return 0;
}
```

### BFS 路径搜索关键点

1. BFS 与最短路径：BFS 按层扩散的特性保证了当它第一次遇到终点时，**所走过的步数就是最短路径长度**。这在无权图（或像本例中所有移动代价相同的网格）中成立。
2. 路径回溯：BFS 本身在搜索过程中并不自然记录完整路径。为了输出路径，需要一个额外的数据结构（如上面的predecessor矩阵）来记录每个节点是由哪个前驱节点访问的。找到终点后，从终点开始，逆着前驱节点回溯直到起点，就能得到完整的最短路径。
3. 方向向量：dx和dy数组定义了移动方向。上面的例子使用了四方向（上、下、左、右），你也可以扩展为八方向（包括对角线）。
4. **访问标记**：`visited` 数组至关重要，它防止了重复访问同一个节点，避免了无限循环，也是 BFS 与 DFS 的一个重要区别。

## Dijkstra算法

Dijkstra算法是计算机科学中非常经典的最短路径算法，由荷兰计算机科学家Edsger W. Dijkstra于1956年提出。它用于在**加权图**（有向或无向）中，找到从单个**源点**（起点）到所有其他节点的**最短路径**。这里的“权重”通常表示距离、成本或时间等概念

### 算法核心思想与特点

Dijkstra算法采用**贪心策略**（Greedy Algorithm）。其核心思想是：

1. **逐步扩展**：从源点开始，逐步确定到其他各顶点的最短路径。
2. **选择当前最短路径**：在每一步中，从未确定最短路径的节点中选择一个距离源点最近的节点，认定其当前距离即为最短距离。
3. 更新邻居距离：然后更新该节点所有邻居节点的当前最短距离。

算法有两个关键特点：

- 非负权重：要求图中所有边的权重均为非负值。若存在负权边，算法可能无法得出正确结果。
- **单源路径**：解决的是单源最短路径问题。

### 算法步骤详解

![DijkStra](pic\DijkStra.png)

### 算法实现

```
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

// 边的结构：目标节点和权重
struct Edge {
    int to;
    int weight;
    Edge(int t, int w) : to(t), weight(w) {}
};

// Dijkstra算法实现
void dijkstra(const vector<vector<Edge>>& graph, int start, vector<int>& distances, vector<int>& predecessors) {
    int n = graph.size();
    distances.assign(n, INT_MAX);  // 初始化距离为无穷大
    predecessors.assign(n, -1);    // 初始化前驱节点为-1
    distances[start] = 0;          // 起点到自身的距离为0
    
    // 优先队列：(距离, 节点)，按距离从小到大排序
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int current_dist = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        
        // 如果当前距离大于已知最短距离，则跳过
        if (current_dist > distances[u]) {
            continue;
        }
        
        // 遍历所有邻接节点
        for (const Edge& edge : graph[u]) {
            int v = edge.to;
            int weight = edge.weight;
            
            // 松弛操作：如果找到更短的路径
            if (distances[v] > distances[u] + weight) {
                distances[v] = distances[u] + weight;
                predecessors[v] = u;
                pq.push({distances[v], v});
            }
        }
    }
}

// 打印从起点到目标节点的最短路径
void printPath(int target, const vector<int>& predecessors) {
    if (predecessors[target] == -1) {
        cout << target;
        return;
    }
    printPath(predecessors[target], predecessors);
    cout << " -> " << target;
}

int main() {
    // 构建图：节点0到4的有向图
    int n = 5;  // 节点数量
    vector<vector<Edge>> graph(n);
    
    // 添加边
    graph[0].emplace_back(1, 4);   // 0->1，权重4
    graph[0].emplace_back(2, 1);   // 0->2，权重1
    graph[2].emplace_back(1, 2);   // 2->1，权重2
    graph[2].emplace_back(3, 5);   // 2->3，权重5
    graph[1].emplace_back(3, 1);   // 1->3，权重1
    graph[3].emplace_back(4, 3);   // 3->4，权重3
    
    int start = 0;  // 起点
    vector<int> distances, predecessors;
    
    // 运行Dijkstra算法
    dijkstra(graph, start, distances, predecessors);
    
    // 输出结果
    cout << "从节点" << start << "到各节点的最短距离：" << endl;
    for (int i = 0; i < n; ++i) {
        if (distances[i] == INT_MAX) {
            cout << "节点" << start << "到节点" << i << "不可达" << endl;
        } else {
            cout << "节点" << start << "到节点" << i << "的最短距离为：" << distances[i] 
                 << "，路径为：";
            printPath(i, predecessors);
            cout << endl;
        }
    }
    
    return 0;
}

输出：
从节点0到各节点的最短距离：
节点0到节点0的最短距离为：0，路径为：0
节点0到节点1的最短距离为：3，路径为：0 -> 2 -> 1
节点0到节点2的最短距离为：1，路径为：0 -> 2
节点0到节点3的最短距离为：4，路径为：0 -> 2 -> 1 -> 3
节点0到节点4的最短距离为：7，路径为：0 -> 2 -> 1 -> 3 -> 4
```

### 优缺点

**优点**：

- 能保证找到最短路径：在非负权图中，可以保证找到源点到所有可达节点的最短路径。
- **效率相对较高**：特别是使用优先队列优化后，在稀疏图中表现良好。

**缺点**：

- 无法处理负权边：如果图中存在负权边，Dijkstra算法可能无法得出正确结果。
- **盲目搜索**：与A*等启发式算法相比，缺乏方向性，可能会探索许多不必要的节点。**权重为1时，就是BFS**。

## A*算法

### 基本原理

A * 算法通过维护每个节点的两个代价来决定搜索方向：

- `g(n)`：从起点到当前节点`n`的实际代价
- `h(n)`：从当前节点`n`到目标节点的估计代价（启发式函数）
- `f(n) = g(n) + h(n)`：节点`n`的总代价，A * 算法总是优先扩展`f(n)`最小的节点

常用的启发式函数有：

- 曼哈顿距离（适合网格地图）：`|x1-x2| + |y1-y2|`
- 欧几里得距离：`√[(x1-x2)² + (y1-y2)²]`

### 算法实现

```C++
#include <iostream>
#include <vector>
#include <queue>
#include <cmath>
#include <algorithm>

using namespace std;

// 定义网格中的节点
struct Node {
    int x, y;          // 坐标
    int g;             // 从起点到当前节点的成本
    int h;             // 从当前节点到目标的估计成本
    Node* parent;      // 父节点指针
    
    Node(int x_, int y_) : x(x_), y(y_), g(0), h(0), parent(nullptr) {}
    
    // f(n) = g(n) + h(n)
    int f() const {
        return g + h;
    }
};

// 比较函数，用于优先队列
struct CompareNode {
    bool operator()(Node* a, Node* b) {
        return a->f() > b->f(); // 小的f值优先
    }
};

// 计算启发函数 (曼哈顿距离)
int heuristic(int x1, int y1, int x2, int y2) {
    return abs(x1 - x2) + abs(y1 - y2);
}

// 检查节点是否在网格范围内
bool isInsideGrid(int x, int y, int rows, int cols) {
    return (x >= 0 && x < rows && y >= 0 && y < cols);
}

// 检查节点是否可通行且未被访问
bool isPassable(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    return (grid[x][y] == 0 && !visited[x][y]);
}

// A*算法实现
vector<pair<int, int>> aStar(const vector<vector<int>>& grid, 
                            int startX, int startY, 
                            int goalX, int goalY) {
    int rows = grid.size();
    if (rows == 0) return {};
    int cols = grid[0].size();
    
    // 方向数组：8个可能的移动方向（上下左右及四个对角线）
    int dirs[8][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1},
                      {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};
    
    // 初始化起点和目标点
    Node* start = new Node(startX, startY);
    Node* goal = new Node(goalX, goalY);
    
    // 优先队列（开放列表）
    priority_queue<Node*, vector<Node*>, CompareNode> openList;
    
    // 已访问节点（关闭列表）
    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    
    // 将起点加入开放列表
    openList.push(start);
    
    // A*主循环
    while (!openList.empty()) {
        // 获取f值最小的节点
        Node* current = openList.top();
        openList.pop();
        
        // 如果到达目标点，回溯路径
        if (current->x == goal->x && current->y == goal->y) {
            vector<pair<int, int>> path;
            while (current != nullptr) {
                path.push_back({current->x, current->y});
                current = current->parent;
            }
            reverse(path.begin(), path.end());
            
            // 清理内存
            delete goal;
            while (!openList.empty()) {
                Node* node = openList.top();
                openList.pop();
                delete node;
            }
            
            return path;
        }
        
        // 标记当前节点为已访问
        visited[current->x][current->y] = true;
        
        // 探索所有相邻节点
        for (int i = 0; i < 8; i++) {
            int newX = current->x + dirs[i][0];
            int newY = current->y + dirs[i][1];
            
            // 检查新位置是否有效
            if (isInsideGrid(newX, newY, rows, cols) && isPassable(grid, visited, newX, newY)) {
                // 创建新节点
                Node* neighbor = new Node(newX, newY);
                neighbor->parent = current;
                neighbor->g = current->g + 1; // 假设每步成本为1
                neighbor->h = heuristic(newX, newY, goal->x, goal->y);
                
                // 将新节点加入开放列表
                openList.push(neighbor);
            }
        }
    }
    
    // 如果没有找到路径
    delete start;
    delete goal;
    return {};
}

int main() {
    // 示例网格地图：0表示可通行，1表示障碍物
    vector<vector<int>> grid = {
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    };
    
    // 起点和目标点坐标
    int startX = 0, startY = 0;
    int goalX = 9, goalY = 9;
    
    // 运行A*算法
    vector<pair<int, int>> path = aStar(grid, startX, startY, goalX, goalY);
    
    // 输出结果
    if (path.empty()) {
        cout << "没有找到路径！" << endl;
    } else {
        cout << "找到路径，长度为: " << path.size() << endl;
        cout << "路径如下: " << endl;
        for (const auto& p : path) {
            cout << "(" << p.first << ", " << p.second << ") ";
            // 在网格上标记路径
            grid[p.first][p.second] = 2;
        }
        cout << endl << endl;
        
        // 打印带路径的网格
        cout << "带路径的网格 (2表示路径):" << endl;
        for (const auto& row : grid) {
            for (int cell : row) {
                if (cell == 1) cout << "# "; // 障碍物
                else if (cell == 2) cout << "* "; // 路径
                else cout << ". "; // 可通行区域
            }
            cout << endl;
        }
    }
    
    return 0;
}

输出：
找到路径，长度为: 11
路径如下: 
(0, 0) (1, 1) (2, 2) (3, 3) (4, 3) (5, 4) (6, 5) (7, 6) (8, 7) (9, 8) (9, 9) 
带路径的网格 (2表示路径):
* . . . # . . . . . 
. * . . # . . . . . 
. . * . # . . . . . 
. . . * # . . . . . 
. . . * # . . . . . 
. . . . * . . . . . 
. . . . # * . . . . 
. . . . # . * . . . 
. . . . # . . * . . 
. . . . . . . . * * 
```

### 最优启发函数

不存在“唯一最优”的启发函数，**最适合你具体问题的启发函数就是最优的**。

- 如果你的问题场景是**四方向移动的网格**，**曼哈顿距离**通常是简单又高效的选择。
- 如果是在**可任意方向移动的连续空间**，**欧几里得距离**更合适。
- 如果允许**八方向移动**，**切比雪夫距离**或**对角线距离**能提供更好的性能

| 启发函数         | 适用场景                                                     | 公式                                                         | 是否可接受 | 特点                                                         |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--------- | :----------------------------------------------------------- |
| **曼哈顿距离**   | 网格地图，仅允许**水平或垂直**移动（四方向）                 | *h*(*n*)=∥*x*1−*x*2∥+∥*y*1−*y*2∥                             | 是         | 计算速度快，在网格环境中简单有效，但对角线移动时会高估实际成本。 |
| **欧几里得距离** | 连续平面或可**任意方向**移动的环境（如机器人导航、无人机规划） | *h*(*n*)=(*x*1−*x*2)2+(*y*1−*y*2)2                           | 是         | 估计更准确，能更好地反映实际距离，但计算开销相对较大（涉及平方和开方）。 |
| **切比雪夫距离** | 网格地图，允许**水平、垂直及对角线**移动（八方向）           | *h*(*n*)=max(∥*x*1−*x*2∥,∥*y*1−*y*2∥)                        | 是         | 适用于国王、皇后等棋子的移动方式，能准确反映八连通网格中的最小移动成本。 |
| **对角线距离**   | 网格地图，允许**八方向**移动，且希望更精确地平衡对角线与直线移动的成本 | *h*(*n*)=max(*dx*,*dy*)+(2−1)⋅min(*dx*,*dy*) 其中 *dx*=∥*x*1−*x*2∥,*dy*=∥*y*1−*y*2∥ | 是         | 比切比雪夫距离更精细，能更好地近似欧几里得距离，同时保持较低的计算复杂度。 |
| **零函数**       | 当没有合适的启发函数或必须**绝对保证找到最优解**，且不计较搜索效率时 | *h*(*n*)=0                                                   | 是         | 此时A*算法退化为Dijkstra算法，能保证找到最优解，但搜索效率最低。 |

八方向移动，对角线距离和欧几里得距离的对比：

![对角线距离](pic\对角线距离.png)

### Tie Breaker

A* 算法中的 **Tie Breaker** 是一种优化策略，用于解决当 **Open List** 中存在多个具有相同总代价估计值（F 值）的节点时，如何选择下一个扩展节点的问题。它的核心目的是在**不影响算法最优性**的前提下，**提升搜索效率**和**路径质量**，避免算法在多个等价路径间反复切换，减少不必要的节点扩展。

| 方法名称                                  | 核心思想                                                     | 优点                                           | 缺点                                                 |
| :---------------------------------------- | :----------------------------------------------------------- | :--------------------------------------------- | :--------------------------------------------------- |
| **次级指标排序**                          | 当 F 值相同时，引入第二个（甚至第三个）排序指标，如优先选择 H 值更小或 G 值更大的节点。 | 实现简单，能有效减少 Open List 大小。          | 需要谨慎选择次级指标，否则可能影响路径质量。         |
| **启发函数微扰 (Heuristic Perturbation)** | 给启发函数值乘以一个极其接近 1 的系数，使原本相等的 F 值产生微小差异。 | 实现简单，能有效打破对称性，引导更直接的路径。 | 若扰动过大，可能破坏启发函数的可接受性，影响最优性。 |
| **交叉距离修正 (Cross Product)**          | 引入一个与当前节点、起点、终点相对位置有关的微小修正量，优先选择与起点-终点向量方向更一致的节点。 | 能促进算法探索更“直接”的路径，减少扩展节点。   | 计算稍复杂，需要理解向量叉乘的概念。                 |

## JPS算法

JPS（Jump Point Search）算法是一种高效的路径搜索算法，是 A * 算法的改进版本。它通过识别 "跳点"（Jump Points）来减少需要探索的节点数量，从而大幅提高搜索效率，特别适合在网格地图上进行路径规划。

### 核心思想

1. **跳点识别**：JPS 算法不是逐个检查相邻节点，而是通过 "跳跃" 的方式直接移动到关键的跳点
2. **强制邻居**：当移动方向改变时，某些节点会成为必须检查的 "强制邻居"
3. **剪枝优化**：通过跳点机制减少了大量不必要的节点探索

### 算法实现

```C++
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <tuple>
#include <cmath>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>

using namespace std;

// 定义方向向量：8个可能的移动方向
const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };
const int dy[] = { -1, 0, 1, -1, 1, -1, 0, 1 };

// 网格节点结构
struct Node {
    int x, y;           // 坐标
    float g, h, f;      // A*算法中的代价函数
    Node* parent;       // 父节点指针
    
    Node(int x_, int y_) : x(x_), y(y_), g(0), h(0), f(0), parent(nullptr) {}
    
    // 用于优先队列的比较
    bool operator>(const Node& other) const {
        return f > other.f;
    }
};

// 哈希函数，用于unordered_map和unordered_set
struct NodeHash {
    size_t operator()(const Node* node) const {
        return hash<int>()(node->x) ^ (hash<int>()(node->y) << 1);
    }
};

struct NodeEqual {
    bool operator()(const Node* a, const Node* b) const {
        return a->x == b->x && a->y == b->y;
    }
};

// 计算启发式距离（曼哈顿距离）
float heuristic(int x1, int y1, int x2, int y2) {
    return abs(x1 - x2) + abs(y1 - y2);
}

// 检查节点是否在网格范围内且可通行
bool isPassable(const vector<vector<int>>& grid, int x, int y) {
    return x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == 0;
}

// 检查是否为目标节点
bool isGoal(Node* node, Node* goal) {
    return node->x == goal->x && node->y == goal->y;
}

// 检查是否存在强制邻居
bool hasForcedNeighbor(const vector<vector<int>>& grid, int x, int y, int dx, int dy) {
    // 对角线移动
    if (dx != 0 && dy != 0) {
        // 检查两个正交方向是否有障碍物
        if ((!isPassable(grid, x - dx, y) && isPassable(grid, x - dx, y + dy)) ||
            (!isPassable(grid, x, y - dy) && isPassable(grid, x + dx, y - dy))) {
            return true;
        }
    } else {
        // 水平或垂直移动
        if (dx != 0) {  // 水平移动
            if ((!isPassable(grid, x, y + 1) && isPassable(grid, x + dx, y + 1)) ||
                (!isPassable(grid, x, y - 1) && isPassable(grid, x + dx, y - 1))) {
                return true;
            }
        } else {  // 垂直移动
            if ((!isPassable(grid, x + 1, y) && isPassable(grid, x + 1, y + dy)) ||
                (!isPassable(grid, x - 1, y) && isPassable(grid, x - 1, y + dy))) {
                return true;
            }
        }
    }
    return false;
    return false;
}

// 跳跃搜索
Node* jump(const vector<vector<int>>& grid, Node* start, int dx, int dy, Node* goal) {
    int x = start->x + dx;
    int y = start->y + dy;
    
    // 检查新位置是否合法
    if (!isPassable(grid, x, y)) {
        return nullptr;
    }
    
    Node* current = new Node(x, y);
    current->parent = start;
    
    // 如果到达目标节点，返回
    if (isGoal(current, goal)) {
        return current;
    }
    
    // 检查是否有强制邻居，如果有则该节点是跳点
    if (hasForcedNeighbor(grid, x, y, dx, dy)) {
        return current;
    }
    
    // 对角线移动时，先检查正交方向是否有跳点
    if (dx != 0 && dy != 0) {
        if (jump(grid, current, dx, 0, goal) != nullptr || 
            jump(grid, current, 0, dy, goal) != nullptr) {
            return current;
        }
    }
    
    // 继续跳跃
    return jump(grid, current, dx, dy, goal);
}

// 获取所有跳点邻居
vector<Node*> getNeighbors(const vector<vector<int>>& grid, Node* node, Node* goal) {
    vector<Node*> neighbors;
    
    // 如果有父节点，只检查相关方向
    if (node->parent != nullptr) {
        int px = node->parent->x;
        int py = node->parent->y;
        
        // 计算方向向量
        int dx = (node->x - px) / max(abs(node->x - px), 1);
        int dy = (node->y - py) / max(abs(node->y - py), 1);
        
        // 沿当前方向跳跃
        Node* jumpNode = jump(grid, node, dx, dy, goal);
        if (jumpNode != nullptr) {
            neighbors.push_back(jumpNode);
        }
        
        // 如果是对角线移动，还需要检查两个正交方向
        if (dx != 0 && dy != 0) {
            // 水平方向
            jumpNode = jump(grid, node, dx, 0, goal);
            if (jumpNode != nullptr) {
                neighbors.push_back(jumpNode);
            }
            
            // 垂直方向
            jumpNode = jump(grid, node, 0, dy, goal);
            if (jumpNode != nullptr) {
                neighbors.push_back(jumpNode);
            }
        }
    } else {
        // 起始节点，检查所有8个方向
        for (int i = 0; i < 8; ++i) {
            Node* jumpNode = jump(grid, node, dx[i], dy[i], goal);
            if (jumpNode != nullptr) {
                neighbors.push_back(jumpNode);
            }
        }
    }
    
    return neighbors;
}

// JPS算法主函数
vector<pair<int, int>> jps(const vector<vector<int>>& grid, pair<int, int> start, pair<int, int> goal) {
    // 初始化起始节点和目标节点
    Node* startNode = new Node(start.first, start.second);
    Node* goalNode = new Node(goal.first, goal.second);
    
    // 优先队列（开放列表）和哈希集合（关闭列表）
    priority_queue<Node*, vector<Node*>, greater<Node*>> openList;
    unordered_set<Node*, NodeHash, NodeEqual> closedList;
    
    // 初始节点加入开放列表
    startNode->h = heuristic(startNode->x, startNode->y, goalNode->x, goalNode->y);
    startNode->f = startNode->g + startNode->h;
    openList.push(startNode);
    
    Node* current = nullptr;
    bool found = false;
    
    while (!openList.empty()) {
        // 取出f值最小的节点
        current = openList.top();
        openList.pop();
        
        // 如果到达目标节点，结束搜索
        if (isGoal(current, goalNode)) {
            found = true;
            break;
        }
        
        // 将当前节点加入关闭列表
        closedList.insert(current);
        
        // 获取所有跳点邻居
        vector<Node*> neighbors = getNeighbors(grid, current, goalNode);
        
        for (Node* neighbor : neighbors) {
            // 如果邻居在关闭列表中，跳过
            if (closedList.find(neighbor) != closedList.end()) {
                continue;
            }
            
            // 计算代价
            float newG = current->g + heuristic(current->x, current->y, neighbor->x, neighbor->y);
            
            // 检查是否已在开放列表中
            bool inOpenList = false;
            // 这里简化处理，实际实现中可能需要更高效的检查方式
            
            if (!inOpenList || newG < neighbor->g) {
                neighbor->g = newG;
                neighbor->h = heuristic(neighbor->x, neighbor->y, goalNode->x, goalNode->y);
                neighbor->f = neighbor->g + neighbor->h;
                neighbor->parent = current;
                
                if (!inOpenList) {
                    openList.push(neighbor);
                }
            }
        }
    }
    
    // 重建路径
    vector<pair<int, int>> path;
    if (found) {
        Node* temp = current;
        while (temp != nullptr) {
            path.push_back({temp->x, temp->y});
            temp = temp->parent;
        }
        reverse(path.begin(), path.end());
    }
    
    // 清理内存
    for (Node* node : closedList) {
        delete node;
    }
    while (!openList.empty()) {
        delete openList.top();
        openList.pop();
    }
    delete goalNode;
    
    return path;
}

// 打印网格和路径
void printGridWithPath(const vector<vector<int>>& grid, const vector<pair<int, int>>& path) {
    vector<vector<char>> displayGrid(grid.size(), vector<char>(grid[0].size(), '.'));
    
    // 标记障碍物
    for (int i = 0; i < grid.size(); ++i) {
        for (int j = 0; j < grid[i].size(); ++j) {
            if (grid[i][j] == 1) {
                displayGrid[i][j] = '#';
            }
        }
    }
    
    // 标记路径
    for (const auto& p : path) {
        if (displayGrid[p.first][p.second] == '.') {
            displayGrid[p.first][p.second] = '*';
        }
    }
    
    // 标记起点和终点
    if (!path.empty()) {
        displayGrid[path.front().first][path.front().second] = 'S';
        displayGrid[path.back().first][path.back().second] = 'G';
    }
    
    // 打印
    for (const auto& row : displayGrid) {
        for (char c : row) {
            cout << c << " ";
        }
        cout << endl;
    }
}

int main() {
    // 示例网格地图：0表示可通行，1表示障碍物
    vector<vector<int>> grid = {
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 1, 1, 1, 1, 0, 1, 1, 0},
        {0, 0, 0, 0, 1, 0, 1, 0, 0},
        {0, 1, 1, 0, 1, 0, 1, 0, 1},
        {0, 1, 0, 0, 0, 0, 1, 0, 0},
        {0, 1, 0, 1, 1, 1, 1, 1, 0},
        {0, 1, 0, 0, 0, 0, 0, 0, 0},
        {0, 1, 1, 1, 1, 1, 1, 1, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0}
    };
    
    // 起点和终点坐标
    pair<int, int> start = {0, 0};
    pair<int, int> goal = {8, 8};
    
    // 执行JPS算法
    vector<pair<int, int>> path = jps(grid, start, goal);
    
    // 输出结果
    if (path.empty()) {
        cout << "无法找到从起点到终点的路径！" << endl;
    } else {
        cout << "找到路径，长度为：" << path.size() << endl;
        cout << "路径如下：" << endl;
        printGridWithPath(grid, path);
        
        cout << "\n坐标路径：" << endl;
        for (const auto& p : path) {
            cout << "(" << p.first << ", " << p.second << ") ";
        }
        cout << endl;
    }
    
    return 0;
}

```



## 总结

|       特性       |        DFS (深度优先搜索)        |      BFS (广度优先搜索)      |       Dijkstra (迪杰斯特拉算法)       |         A* (A-Star算法)          |
| :--------------: | :------------------------------: | :--------------------------: | :-----------------------------------: | :------------------------------: |
|   **核心思想**   |       一条路走到黑，再回溯       |      按层扩散，稳扎稳打      |    优先选择当前累积代价最小的路径     |  综合累积代价和到目标的估计代价  |
|   **数据结构**   |        栈 (Stack) / 递归         |         队列 (Queue)         |       优先队列 (Priority Queue)       |    优先队列 (Priority Queue)     |
|   **是否最优**   |        否（除非额外处理）        |     **是**（在无权图中）     |       **是**（在带权非负图中）        |    **是**（启发函数可采纳时）    |
|  **时间复杂度**  |         O(\|V\|+ \|E\|)          |       O(\|V\|+ \|E\|)        | O((\|V\|+\|E\|) log \|V\|) (优先队列) | 取决于启发函数，最坏情况 O(b^d)  |
|  **空间复杂度**  |             O(\|V\|)             |           O(\|V\|)           |               O(\|V\|)                |             O(\|V\|)             |
| **主要适用场景** | 拓扑排序、连通性检测、寻找所有解 | 无权图最短路径、层次关系分析 |   带权非负图最短路径（如路由协议）    | 路径规划（如游戏AI、机器人导航） |

### 算法简要说明

1. **DFS (深度优先搜索)**：像探险家深入迷宫，先一条路走到底，再回溯尝试其他岔路。**不保证找到最短路径**，但**内存消耗相对较低**（通常与树的高度成正比）。适合需要**遍历所有可能性**的场景，如拓扑排序、连通性检测或求解排列组合问题。

2. **BFS (广度优先搜索)**：像水波扩散，层层推进，总是先访问离起点最近的节点。在**无权图**中能**保证找到最短路径**。缺点是**内存消耗较大**（与树的宽度成正比），因为需要存储每一层的节点。适合社交网络层级分析、迷宫最短路径等。

3. **Dijkstra算法**：可以看作是BFS在**带权图**（边的权重非负）上的扩展。它通过**优先队列**，总是优先扩展从起点到当前点**累积代价（g(n)）最小**的节点，从而保证在非负权图中找到最短路径。常用于网络路由、地图导航等。

4. **A\*算法**：在Dijkstra的基础上，增加了一个**启发函数（h(n)）**来估计当前点到目标点的代价，其评估函数为 **f(n) = g(n) + h(n)**（g(n)是实际代价，h(n)是估计代价）*。这样搜索会更有方向性，效率通常远高于Dijkstra

   。*只要启发函数 h(n) 是可采纳的（即从不高估实际代价），A*就能保证找到**最短路径**。广泛应用于游戏AI、机器人路径规划等领域。

###  如何选择算法

选择算法时，考虑以下几点：

- **图是否有权重**：如果图**没有权重**，追求最短路径可选用**BFS**；若只需连通性或遍历所有路径，**DFS**可能更省内存。如果图**有权重**且**权重非负**，需要最短路径，**Dijkstra**是可靠选择。
- **是否需要最优解**：追求**最短路径**或**最小代价**时，BFS（无权）、Dijkstra（带权非负）、A*（启发函数可采纳）都可以保证。**若解是否存在比是否最优更重要，或需要所有可能解，DFS更合适**。
- **是否有启发信息**：如果存在良好的启发函数来估计到目标的距离（如地图上的直线距离），**A\*** 通常能**显著提高搜索效率**。
- **空间与时间效率的权衡**：**DFS**通常空间效率较高，但可能“误入歧途”；**BFS**和**Dijkstra**保证最优但空间开销可能较大；**A\*** 在好的启发函数下可以兼顾效率和最优性

